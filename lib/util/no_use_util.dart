class NoUseUtil {
  const NoUseUtil._();

  static const testMessage = """
Android 支持长读取，iOS 不支持，需要自定义数据协议并校验完整性。通常定义前几位作为头部并校验前几位和长度。

字节流处理:
1. 整条消息序列化，开头携带长度，但接收方如何做同步 (是否仅拼接)。
2. 消息头包含消息id、包索引、包长度。

方案:
1. 参考 GitHub 协议，不能直接用但可借鉴结构: 首包 2 字节长度、1 字节块大小、1 字节校验和；后续包 1 字节块索引、1 字节校验和。
2. 让 AI 根据现有协议生成代码。方法是串行调用，complete 会等待，跨 read 和 write 无法使用同步锁，send 方法需要再查看。
3. 使用同步块串行写入逻辑，在首包封装长度，全局串行处理也可行。
协议示例:
首包: 1 字节异或校验、1 字节版本、2 字节头标识、1 字节动作标识、2 字节总包数。
后续包: 1 字节异或校验、2 字节包索引。
存在错误包，用标识表示；收到错误包需重置所有内容，错误包为单包结束。
处理流程:
1. packets 为空且收到首包時创建 packets。
2. packets 不为空則视为后续包并拼接。

拼包需要使用 map 避免乱序。部分实现不处理错误和乱序，通过延迟解决，因此仍需要考虑乱序。

协议层: 自定义协议加串行处理比较简单。
应用层: 要么解析字符串 (需要原子化命令)，要么定义方法标识 (需要侵入协议层""";
}
